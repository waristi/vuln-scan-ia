package com.mercadolibre.vulnscania.infrastructure.adapter.output.event;

import com.mercadolibre.vulnscania.domain.event.AssessmentCompletedEvent;
import com.mercadolibre.vulnscania.domain.event.ScoreAdjustedEvent;
import com.mercadolibre.vulnscania.domain.event.VulnerabilityCriticalEvent;
import com.mercadolibre.vulnscania.domain.event.VulnerabilityDetectedEvent;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.event.EventListener;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Component;

/**
 * Event Listener for Domain Events related to vulnerabilities.
 * 
 * <p>This listener is part of the infrastructure layer and handles domain events
 * emitted by the domain layer. It performs side effects such as:</p>
 * <ul>
 *   <li>Logging and auditing</li>
 *   <li>Sending notifications</li>
 *   <li>Updating metrics/dashboards</li>
 *   <li>Triggering external workflows</li>
 * </ul>
 * 
 * <p>Note: These listeners are marked as @Async to avoid blocking the main
 * transaction. This ensures that domain event processing doesn't slow down
 * the main use case execution.</p>
 * 
 * <p>Architecture Note: Event listeners belong to the infrastructure layer,
 * NOT the domain layer. This keeps the domain clean and framework-independent.</p>
 */
@Component
public class VulnerabilityEventListener {
    
    private static final Logger log = LoggerFactory.getLogger(VulnerabilityEventListener.class);
    
    /**
     * Handles VulnerabilityDetectedEvent.
     * 
     * <p>Triggered when a new vulnerability is detected in an application.
     * This is the starting point for vulnerability tracking.</p>
     * 
     * <p>Actions performed:</p>
     * <ul>
     *   <li>Log the detection for auditing</li>
     *   <li>Update monitoring dashboards</li>
     *   <li>Trigger vulnerability tracking workflows</li>
     * </ul>
     * 
     * @param event the vulnerability detected event
     */
    @EventListener
    @Async
    public void handleVulnerabilityDetected(VulnerabilityDetectedEvent event) {
        log.info("üîç Vulnerability Detected: CVE={}, Application={}, BaseScore={}", 
            event.cveId().value(), 
            event.applicationId().value(),
            event.baseScore().value());
        
        // TODO: Implement additional actions:
        // - Send notification to development team
        // - Update vulnerability dashboard
        // - Trigger CI/CD pipeline checks
        // - Create tracking ticket in issue tracker
        // - Update security metrics
        
        logAuditEvent("VULNERABILITY_DETECTED", event.cveId().value(), event.applicationId().value());
    }
    
    /**
     * Handles VulnerabilityCriticalEvent.
     * 
     * <p>Triggered when a CRITICAL vulnerability is detected (score >= 9.0).
     * This requires immediate attention and urgent action.</p>
     * 
     * <p>Actions performed:</p>
     * <ul>
     *   <li>Log CRITICAL alert</li>
     *   <li>Send urgent notifications to security team</li>
     *   <li>Create high-priority incident</li>
     *   <li>Trigger emergency response procedures</li>
     * </ul>
     * 
     * @param event the critical vulnerability event
     */
    @EventListener
    @Async
    public void handleCriticalVulnerability(VulnerabilityCriticalEvent event) {
        log.warn("üö® CRITICAL Vulnerability Detected: CVE={}, Application={}, Score={}", 
            event.cveId().value(), 
            event.applicationId().value(),
            event.contextualScore().value());
        
        // TODO: Implement critical actions:
        // - Send URGENT notification (email, Slack, PagerDuty)
        // - Alert security team immediately
        // - Create high-priority incident ticket
        // - Trigger emergency response workflow
        // - Update security SLA tracking
        // - Potentially block deployments
        
        logAuditEvent("CRITICAL_VULNERABILITY", event.cveId().value(), event.applicationId().value());
    }
    
    /**
     * Handles ScoreAdjustedEvent.
     * 
     * <p>Triggered when a vulnerability's score is adjusted (e.g., after AI analysis
     * or manual review).</p>
     * 
     * <p>Actions performed:</p>
     * <ul>
     *   <li>Log the score change</li>
     *   <li>Update metrics for score adjustments</li>
     *   <li>Track AI accuracy over time</li>
     * </ul>
     * 
     * @param event the score adjusted event
     */
    @EventListener
    @Async
    public void handleScoreAdjusted(ScoreAdjustedEvent event) {
        log.info("üìä Score Adjusted: VulnerabilityID={}, OldScore={}, NewScore={}, Justification={}", 
            event.vulnerabilityId().value(), 
            event.oldScore().value(),
            event.newScore().value(),
            event.justification());
        
        // TODO: Implement actions:
        // - Track score adjustment patterns
        // - Update AI accuracy metrics
        // - Notify stakeholders if significant change
        // - Log for compliance/audit
        
        logAuditEvent("SCORE_ADJUSTED", event.vulnerabilityId().value(), 
            String.format("%.1f -> %.1f", event.oldScore().value(), event.newScore().value()));
    }
    
    /**
     * Handles AssessmentCompletedEvent.
     * 
     * <p>Triggered when a vulnerability assessment is completed.
     * This marks the end of the evaluation process.</p>
     * 
     * <p>Actions performed:</p>
     * <ul>
     *   <li>Log assessment completion</li>
     *   <li>Update completion metrics</li>
     *   <li>Generate reports</li>
     *   <li>Trigger next steps in workflow</li>
     * </ul>
     * 
     * @param event the assessment completed event
     */
    @EventListener
    @Async
    public void handleAssessmentCompleted(AssessmentCompletedEvent event) {
        log.info("‚úÖ Assessment Completed: AssessmentID={}, VulnerabilityID={}, FinalScore={}, Confidence={}", 
            event.assessmentId().value(), 
            event.vulnerabilityId().value(),
            event.finalScore().value(),
            event.confidenceLevel());
        
        // TODO: Implement actions:
        // - Generate assessment report
        // - Update completion metrics
        // - Trigger downstream workflows (remediation, notification)
        // - Update dashboards with latest assessment
        // - Store for historical analysis
        
        logAuditEvent("ASSESSMENT_COMPLETED", event.assessmentId().value(), event.vulnerabilityId().value());
    }
    
    /**
     * Logs an audit event for compliance and tracking.
     * 
     * <p>In a production system, this would typically:</p>
     * <ul>
     *   <li>Write to a dedicated audit log (e.g., file, database, service)</li>
     *   <li>Include timestamp, user, IP address, etc.</li>
     *   <li>Be indexed for search and analysis</li>
     *   <li>Be retained per compliance requirements</li>
     * </ul>
     * 
     * @param eventType the type of event
     * @param primaryId the primary identifier (CVE ID, Assessment ID, etc.)
     * @param secondaryId optional secondary identifier
     */
    private void logAuditEvent(String eventType, String primaryId, String secondaryId) {
        // In production: write to audit log system
        log.debug("AUDIT: type={}, primaryId={}, secondaryId={}", 
            eventType, primaryId, secondaryId);
    }
}

