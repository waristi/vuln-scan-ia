package com.mercadolibre.vulnscania.domain.model.vulnerability;

import com.mercadolibre.vulnscania.domain.event.DomainEvent;
import com.mercadolibre.vulnscania.domain.event.VulnerabilityDetectedEvent;
import com.mercadolibre.vulnscania.domain.event.VulnerabilityCriticalEvent;
import com.mercadolibre.vulnscania.domain.event.ScoreAdjustedEvent;
import com.mercadolibre.vulnscania.domain.exception.InvalidStateTransitionException;
import com.mercadolibre.vulnscania.domain.model.application.ApplicationId;

import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * Aggregate Root: Vulnerability
 * 
 * Represents a security vulnerability detected in an open-source dependency.
 * Encapsulates all business rules related to the vulnerability lifecycle.
 * 
 * Business Rules:
 * - Contextual score cannot be reduced if vulnerability is CRITICAL
 * - State transitions are validated (only certain states can transition to CRITICAL)
 * - Emits domain events when state changes
 * - Base score is immutable, contextual score can be adjusted
 */
public class Vulnerability {
    
    private final VulnerabilityId id;
    private final CveId cveId;
    private final ApplicationId applicationId;
    private final Instant detectedAt;
    
    private SeverityScore baseScore;
    private SeverityScore contextualScore;
    private CvssVector cvssVector;
    private VulnerabilityStatus status;
    private VulnerabilityType type;
    private String description;
    private String aiJustification;
    
    private final List<DomainEvent> domainEvents = new ArrayList<>();
    
    private Vulnerability(VulnerabilityId id, 
                         CveId cveId, 
                         ApplicationId applicationId,
                         SeverityScore baseScore,
                         Instant detectedAt) {
        this.id = Objects.requireNonNull(id, "Vulnerability ID is required");
        this.cveId = Objects.requireNonNull(cveId, "CVE ID is required");
        this.applicationId = Objects.requireNonNull(applicationId, "Application ID is required");
        this.baseScore = Objects.requireNonNull(baseScore, "Base score is required");
        this.contextualScore = baseScore;
        this.detectedAt = detectedAt != null ? detectedAt : Instant.now();
        this.status = VulnerabilityStatus.PENDING;
        this.type = VulnerabilityType.OTHER;
    }
    
    /**
     * Factory method to create a new detected vulnerability.
     *
     * @param cveId the CVE identifier
     * @param applicationId the affected application ID
     * @param baseScore the base CVSS score
     * @return a new Vulnerability instance
     */
    public static Vulnerability create(CveId cveId, 
                                      ApplicationId applicationId, 
                                      SeverityScore baseScore) {
        Vulnerability vulnerability = new Vulnerability(
            VulnerabilityId.generate(),
            cveId,
            applicationId,
            baseScore,
            Instant.now()
        );
        
        vulnerability.recordEvent(new VulnerabilityDetectedEvent(
            vulnerability.id,
            vulnerability.cveId,
            vulnerability.applicationId,
            vulnerability.baseScore,
            vulnerability.detectedAt
        ));
        
        return vulnerability;
    }
    
    /**
     * Factory method for reconstitution from persistence.
     *
     * @param id the vulnerability ID
     * @param cveId the CVE ID
     * @param applicationId the application ID
     * @param baseScore the base score
     * @param contextualScore the contextual score
     * @param status the current status
     * @param detectedAt the detection timestamp
     * @return a reconstituted Vulnerability instance
     */
    public static Vulnerability reconstitute(VulnerabilityId id,
                                            CveId cveId,
                                            ApplicationId applicationId,
                                            SeverityScore baseScore,
                                            SeverityScore contextualScore,
                                            VulnerabilityStatus status,
                                            Instant detectedAt) {
        Vulnerability vulnerability = new Vulnerability(id, cveId, applicationId, baseScore, detectedAt);
        vulnerability.contextualScore = contextualScore;
        vulnerability.status = status;
        return vulnerability;
    }
    
    /**
     * Adjusts the contextual score based on AI analysis.
     * 
     * Business rule: Contextual score cannot be reduced if vulnerability is CRITICAL.
     *
     * @param newContextualScore the new contextual score
     * @param justification the justification for the adjustment
     * @throws IllegalStateException if trying to reduce a CRITICAL vulnerability score
     */
    public void adjustContextualScore(SeverityScore newContextualScore, String justification) {
        Objects.requireNonNull(newContextualScore, "Contextual score is required");
        
        SeverityScore oldScore = this.contextualScore;
        
        if (this.status == VulnerabilityStatus.CRITICAL && 
            newContextualScore.value() < oldScore.value()) {
            throw new IllegalStateException(
                "Cannot reduce score of a CRITICAL vulnerability from " + 
                oldScore.value() + " to " + newContextualScore.value()
            );
        }
        
        this.contextualScore = newContextualScore;
        this.aiJustification = justification;
        
        recordEvent(new ScoreAdjustedEvent(
            this.id,
            oldScore,
            newContextualScore,
            justification,
            Instant.now()
        ));
        
        if (newContextualScore.isCritical() && status.canMarkAsCritical()) {
            markAsCritical("Auto-marked due to critical contextual score: " + justification);
        }
    }
    
    /**
     * Marks the vulnerability as critical.
     * 
     * Business rule: Can only be marked as critical from certain states (PENDING, UNDER_ANALYSIS, CONFIRMED).
     *
     * @param reason the reason for marking as critical
     * @throws InvalidStateTransitionException if the current state doesn't allow transitioning to CRITICAL
     */
    public void markAsCritical(String reason) {
        Objects.requireNonNull(reason, "Reason is required");
        
        if (!status.canMarkAsCritical()) {
            throw new InvalidStateTransitionException(
                status.name(),
                VulnerabilityStatus.CRITICAL.name()
            );
        }
        
        this.status = VulnerabilityStatus.CRITICAL;
        
        recordEvent(new VulnerabilityCriticalEvent(
            this.id,
            this.cveId,
            this.applicationId,
            this.contextualScore,
            reason,
            Instant.now()
        ));
    }
    
    /**
     * Confirms the vulnerability after analysis.
     */
    public void confirm() {
        if (this.status == VulnerabilityStatus.PENDING || 
            this.status == VulnerabilityStatus.UNDER_ANALYSIS) {
            this.status = VulnerabilityStatus.CONFIRMED;
        }
    }
    
    /**
     * Marks the vulnerability as a false positive.
     *
     * @param reason the reason for marking as false positive
     * @throws InvalidStateTransitionException if the current state is final
     */
    public void markAsFalsePositive(String reason) {
        if (status.isFinal()) {
            throw new InvalidStateTransitionException(
                status.name(),
                VulnerabilityStatus.FALSE_POSITIVE.name()
            );
        }
        this.status = VulnerabilityStatus.FALSE_POSITIVE;
    }
    
    /**
     * Marks the vulnerability as mitigated.
     *
     * @param mitigationDescription the description of the applied mitigation
     * @throws InvalidStateTransitionException if the current state is FALSE_POSITIVE
     */
    public void markAsMitigated(String mitigationDescription) {
        Objects.requireNonNull(mitigationDescription, "Mitigation description is required");
        
        if (this.status == VulnerabilityStatus.FALSE_POSITIVE) {
            throw new InvalidStateTransitionException(
                status.name(),
                VulnerabilityStatus.MITIGATED.name()
            );
        }
        
        this.status = VulnerabilityStatus.MITIGATED;
    }
    
    /**
     * Determines if the vulnerability requires immediate action.
     * 
     * Business rule: Requires action if CRITICAL status OR contextual score >= 7.0.
     *
     * @return true if immediate action is required
     */
    public boolean requiresImmediateAction() {
        return this.status == VulnerabilityStatus.CRITICAL || 
               this.contextualScore.requiresAction();
    }
    
    /**
     * Calculates the categorical severity level.
     *
     * @return the severity level based on contextual score
     */
    public SeverityLevel getSeverityLevel() {
        return SeverityLevel.fromScore(contextualScore.value());
    }
    
    /**
     * Updates additional metadata for the vulnerability.
     *
     * @param cvssVector the CVSS vector string
     * @param type the vulnerability type
     * @param description the vulnerability description
     */
    public void updateMetadata(CvssVector cvssVector, VulnerabilityType type, String description) {
        this.cvssVector = cvssVector;
        this.type = type != null ? type : VulnerabilityType.OTHER;
        this.description = description;
    }
    
    private void recordEvent(DomainEvent event) {
        this.domainEvents.add(event);
    }
    
    /**
     * Pulls and clears all accumulated domain events.
     * This method should be called after persisting the aggregate to publish events.
     *
     * @return the list of domain events
     */
    public List<DomainEvent> pullDomainEvents() {
        List<DomainEvent> events = new ArrayList<>(this.domainEvents);
        this.domainEvents.clear();
        return events;
    }
    
    public VulnerabilityId getId() {
        return id;
    }
    
    public CveId getCveId() {
        return cveId;
    }
    
    public ApplicationId getApplicationId() {
        return applicationId;
    }
    
    public SeverityScore getBaseScore() {
        return baseScore;
    }
    
    public SeverityScore getContextualScore() {
        return contextualScore;
    }
    
    public CvssVector getCvssVector() {
        return cvssVector;
    }
    
    public VulnerabilityStatus getStatus() {
        return status;
    }
    
    public VulnerabilityType getType() {
        return type;
    }
    
    public String getDescription() {
        return description;
    }
    
    public String getAiJustification() {
        return aiJustification;
    }
    
    public Instant getDetectedAt() {
        return detectedAt;
    }
}
