package com.mercadolibre.vulnscania.domain.model.vulnerability;

import com.mercadolibre.vulnscania.domain.event.DomainEvent;
import com.mercadolibre.vulnscania.domain.event.VulnerabilityDetectedEvent;
import com.mercadolibre.vulnscania.domain.event.VulnerabilityCriticalEvent;
import com.mercadolibre.vulnscania.domain.event.ScoreAdjustedEvent;
import com.mercadolibre.vulnscania.domain.exception.InvalidStateTransitionException;
import com.mercadolibre.vulnscania.domain.model.application.Application;
import com.mercadolibre.vulnscania.domain.model.application.ApplicationId;

import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * Aggregate Root: Vulnerability
 * 
 * Represents a security vulnerability detected in an open-source dependency.
 * Encapsulates all business rules related to the vulnerability lifecycle.
 * 
 * Business Rules:
 * - Contextual score cannot be reduced if vulnerability is CRITICAL
 * - State transitions are validated (only certain states can transition to CRITICAL)
 * - Emits domain events when state changes
 * - Base score is immutable, contextual score can be adjusted
 */
public class Vulnerability {
    
    // Contextual scoring business constants
    private static final double INTERNET_EXPOSURE_MULTIPLIER = 0.3;
    private static final double PRODUCTION_ENV_MULTIPLIER = 0.2;
    private static final double CRITICAL_INFRA_MULTIPLIER = 0.3;
    private static final double RECENT_CVE_MULTIPLIER = 0.1;
    private static final double MITIGATION_REDUCTION_PER_ITEM = 0.1;
    private static final double MAX_MITIGATION_REDUCTION = 0.3;
    private static final double MAX_CONTEXTUAL_ADJUSTMENT = 2.0;
    private static final double MIN_CONTEXTUAL_FACTOR = 0.8;
    
    // SLA response time constants (in hours)
    private static final int SLA_CRITICAL_HOURS = 4;
    private static final int SLA_HIGH_HOURS = 24;
    private static final int SLA_MEDIUM_HOURS = 7 * 24;  // 7 days
    private static final int SLA_LOW_HOURS = 30 * 24;    // 30 days
    private static final int SLA_MINIMUM_HOURS = 1;
    private static final double CRITICAL_INFRA_SLA_REDUCTION = 0.5;
    
    private final VulnerabilityId id;
    private final CveId cveId;
    private final ApplicationId applicationId;
    private final Instant detectedAt;
    
    private SeverityScore baseScore;
    private SeverityScore contextualScore;
    private CvssVector cvssVector;
    private VulnerabilityStatus status;
    private VulnerabilityType type;
    private String description;
    private String aiJustification;
    
    private final List<DomainEvent> domainEvents = new ArrayList<>();
    
    private Vulnerability(VulnerabilityId id, 
                         CveId cveId, 
                         ApplicationId applicationId,
                         SeverityScore baseScore,
                         Instant detectedAt) {
        this.id = Objects.requireNonNull(id, "Vulnerability ID is required");
        this.cveId = Objects.requireNonNull(cveId, "CVE ID is required");
        this.applicationId = Objects.requireNonNull(applicationId, "Application ID is required");
        this.baseScore = Objects.requireNonNull(baseScore, "Base score is required");
        this.contextualScore = baseScore;
        this.detectedAt = detectedAt != null ? detectedAt : Instant.now();
        this.status = VulnerabilityStatus.PENDING;
        this.type = VulnerabilityType.OTHER;
    }
    
    /**
     * Factory method to create a new detected vulnerability.
     *
     * @param cveId the CVE identifier
     * @param applicationId the affected application ID
     * @param baseScore the base CVSS score
     * @return a new Vulnerability instance
     */
    public static Vulnerability create(CveId cveId, 
                                      ApplicationId applicationId, 
                                      SeverityScore baseScore) {
        Vulnerability vulnerability = new Vulnerability(
            VulnerabilityId.generate(),
            cveId,
            applicationId,
            baseScore,
            Instant.now()
        );
        
        vulnerability.recordEvent(new VulnerabilityDetectedEvent(
            vulnerability.id,
            vulnerability.cveId,
            vulnerability.applicationId,
            vulnerability.baseScore,
            vulnerability.detectedAt
        ));
        
        return vulnerability;
    }
    
    /**
     * Factory method for reconstitution from persistence.
     *
     * @param id the vulnerability ID
     * @param cveId the CVE ID
     * @param applicationId the application ID
     * @param baseScore the base score
     * @param contextualScore the contextual score
     * @param status the current status
     * @param detectedAt the detection timestamp
     * @return a reconstituted Vulnerability instance
     */
    public static Vulnerability reconstitute(VulnerabilityId id,
                                            CveId cveId,
                                            ApplicationId applicationId,
                                            SeverityScore baseScore,
                                            SeverityScore contextualScore,
                                            VulnerabilityStatus status,
                                            Instant detectedAt) {
        Vulnerability vulnerability = new Vulnerability(id, cveId, applicationId, baseScore, detectedAt);
        vulnerability.contextualScore = contextualScore;
        vulnerability.status = status;
        return vulnerability;
    }
    
    /**
     * Adjusts the contextual score based on AI analysis.
     * 
     * Business rule: Contextual score cannot be reduced if vulnerability is CRITICAL.
     *
     * @param newContextualScore the new contextual score
     * @param justification the justification for the adjustment
     * @throws IllegalStateException if trying to reduce a CRITICAL vulnerability score
     */
    public void adjustContextualScore(SeverityScore newContextualScore, String justification) {
        Objects.requireNonNull(newContextualScore, "Contextual score is required");
        
        SeverityScore oldScore = this.contextualScore;
        
        if (this.status == VulnerabilityStatus.CRITICAL && 
            newContextualScore.value() < oldScore.value()) {
            throw new IllegalStateException(
                "Cannot reduce score of a CRITICAL vulnerability from " + 
                oldScore.value() + " to " + newContextualScore.value()
            );
        }
        
        this.contextualScore = newContextualScore;
        this.aiJustification = justification;
        
        recordEvent(new ScoreAdjustedEvent(
            this.id,
            oldScore,
            newContextualScore,
            justification,
            Instant.now()
        ));
        
        if (newContextualScore.isCritical() && status.canMarkAsCritical()) {
            markAsCritical("Auto-marked due to critical contextual score: " + justification);
        }
    }
    
    /**
     * Marks the vulnerability as critical.
     * 
     * Business rule: Can only be marked as critical from certain states (PENDING, UNDER_ANALYSIS, CONFIRMED).
     *
     * @param reason the reason for marking as critical
     * @throws InvalidStateTransitionException if the current state doesn't allow transitioning to CRITICAL
     */
    public void markAsCritical(String reason) {
        Objects.requireNonNull(reason, "Reason is required");
        
        if (!status.canMarkAsCritical()) {
            throw new InvalidStateTransitionException(
                status.name(),
                VulnerabilityStatus.CRITICAL.name()
            );
        }
        
        this.status = VulnerabilityStatus.CRITICAL;
        
        recordEvent(new VulnerabilityCriticalEvent(
            this.id,
            this.cveId,
            this.applicationId,
            this.contextualScore,
            reason,
            Instant.now()
        ));
    }
    
    /**
     * Confirms the vulnerability after analysis.
     */
    public void confirm() {
        if (this.status == VulnerabilityStatus.PENDING || 
            this.status == VulnerabilityStatus.UNDER_ANALYSIS) {
            this.status = VulnerabilityStatus.CONFIRMED;
        }
    }
    
    /**
     * Marks the vulnerability as a false positive.
     *
     * @param reason the reason for marking as false positive
     * @throws InvalidStateTransitionException if the current state is final
     */
    public void markAsFalsePositive(String reason) {
        if (status.isFinal()) {
            throw new InvalidStateTransitionException(
                status.name(),
                VulnerabilityStatus.FALSE_POSITIVE.name()
            );
        }
        this.status = VulnerabilityStatus.FALSE_POSITIVE;
    }
    
    /**
     * Marks the vulnerability as mitigated.
     *
     * @param mitigationDescription the description of the applied mitigation
     * @throws InvalidStateTransitionException if the current state is FALSE_POSITIVE
     */
    public void markAsMitigated(String mitigationDescription) {
        Objects.requireNonNull(mitigationDescription, "Mitigation description is required");
        
        if (this.status == VulnerabilityStatus.FALSE_POSITIVE) {
            throw new InvalidStateTransitionException(
                status.name(),
                VulnerabilityStatus.MITIGATED.name()
            );
        }
        
        this.status = VulnerabilityStatus.MITIGATED;
    }
    
    /**
     * Calculates the categorical severity level.
     *
     * @return the severity level based on contextual score
     */
    public SeverityLevel getSeverityLevel() {
        return SeverityLevel.fromScore(contextualScore.value());
    }
    
    /**
     * Updates additional metadata for the vulnerability.
     *
     * @param cvssVector the CVSS vector string
     * @param type the vulnerability type
     * @param description the vulnerability description
     */
    public void updateMetadata(CvssVector cvssVector, VulnerabilityType type, String description) {
        this.cvssVector = cvssVector;
        this.type = type != null ? type : VulnerabilityType.OTHER;
        this.description = description;
    }
    
    private void recordEvent(DomainEvent event) {
        this.domainEvents.add(event);
    }
    
    // ========== RICH DOMAIN MODEL: Business Logic Methods ==========
    
    /**
     * Calculates the contextual score for this vulnerability based on application context.
     * 
     * <p>This is the CORE business logic for contextual scoring. It applies multiple risk factors
     * from the application context to adjust the base CVSS score.</p>
     * 
     * <p>Business Rules:</p>
     * <ul>
     *   <li>Factor 1: Internet exposure increases risk by 30%</li>
     *   <li>Factor 2: Data sensitivity applies variable multiplier</li>
     *   <li>Factor 3: Production environment increases risk by 20%</li>
     *   <li>Factor 4: Critical infrastructure increases risk by 30%</li>
     *   <li>Factor 5: Recent CVE (emerging threat) increases risk by 10%</li>
     *   <li>Factor 6: Known mitigations reduce risk by up to 30%</li>
     *   <li>Maximum adjustment: +2.0 points</li>
     *   <li>Minimum score: 80% of base score</li>
     * </ul>
     * 
     * <p>This follows the "Tell, Don't Ask" principle - the vulnerability knows how to calculate
     * its own contextual score given an application context.</p>
     * 
     * @param application the application context for scoring
     * @return the calculated contextual score
     */
    public SeverityScore calculateContextualScore(Application application) {
        double baseScoreValue = this.baseScore.value();
        double adjustment = 0.0;
        
        // Factor 1: Internet exposure (+30%)
        if (application.isInternetExposed()) {
            adjustment += baseScoreValue * INTERNET_EXPOSURE_MULTIPLIER;
        }
        
        // Factor 2: Data sensitivity (variable multiplier)
        double dataSensitivityMultiplier = application.getDataSensitivity().getRiskMultiplier();
        if (dataSensitivityMultiplier > 1.0) {
            adjustment += baseScoreValue * (dataSensitivityMultiplier - 1.0);
        }
        
        // Factor 3: Production environment (+20%)
        if (application.isInProduction()) {
            adjustment += baseScoreValue * PRODUCTION_ENV_MULTIPLIER;
        }
        
        // Factor 4: Critical infrastructure (+30% additional)
        if (application.isCriticalInfrastructure()) {
            adjustment += baseScoreValue * CRITICAL_INFRA_MULTIPLIER;
        }
        
        // Factor 5: Recent CVE - emerging threat (+10%)
        if (this.cveId.isRecent()) {
            adjustment += baseScoreValue * RECENT_CVE_MULTIPLIER;
        }
        
        // Factor 6: Known mitigations reduce risk
        int mitigationsCount = application.getKnownMitigations().size();
        if (mitigationsCount > 0) {
            double reduction = Math.min(MAX_MITIGATION_REDUCTION, 
                                       mitigationsCount * MITIGATION_REDUCTION_PER_ITEM);
            adjustment -= baseScoreValue * reduction;
        }
        
        // Apply maximum adjustment limit
        adjustment = Math.min(adjustment, MAX_CONTEXTUAL_ADJUSTMENT);
        
        // Calculate final score with minimum threshold (cannot go below 80% of base)
        double minAllowedScore = baseScoreValue * MIN_CONTEXTUAL_FACTOR;
        double contextualScoreValue = Math.max(minAllowedScore, baseScoreValue + adjustment);
        
        // Clamp to valid CVSS range [0.0, 10.0]
        contextualScoreValue = Math.min(SeverityScore.MAX_SCORE, 
                                       Math.max(SeverityScore.MIN_SCORE, contextualScoreValue));
        
        return new SeverityScore(contextualScoreValue);
    }
    
    /**
     * Determines if this vulnerability requires immediate action based on application context.
     * 
     * <p>Business Rules for immediate action:</p>
     * <ul>
     *   <li>Always required if contextual score >= 9.0 (Critical)</li>
     *   <li>Required if score >= 7.0 (High) AND (internet exposed OR in production)</li>
     *   <li>Required if critical infrastructure AND score >= 6.0</li>
     * </ul>
     * 
     * <p>This encapsulates the business logic for triaging vulnerability responses,
     * allowing the domain model to make intelligent decisions based on context.</p>
     * 
     * @param application the application context
     * @return true if immediate action is required
     */
    public boolean requiresImmediateAction(Application application) {
        SeverityScore contextual = calculateContextualScore(application);
        
        // Always critical if score >= 9.0
        if (contextual.isCritical()) {
            return true;
        }
        
        // High score with exposure or production requires action
        if (contextual.isHigh() && 
            (application.isInternetExposed() || application.isInProduction())) {
            return true;
        }
        
        // Critical infrastructure with medium-high score requires action
        if (application.isCriticalInfrastructure() && contextual.value() >= 6.0) {
            return true;
        }
        
        return false;
    }
    
    /**
     * Calculates the response time SLA (Service Level Agreement) in hours for this vulnerability.
     * 
     * <p>SLA Business Rules:</p>
     * <ul>
     *   <li>Critical (>= 9.0): 4 hours</li>
     *   <li>High (>= 7.0): 24 hours (1 day)</li>
     *   <li>Medium (>= 4.0): 168 hours (7 days)</li>
     *   <li>Low (< 4.0): 720 hours (30 days)</li>
     *   <li>Critical infrastructure: SLA is halved</li>
     *   <li>Minimum SLA: 1 hour (cannot be zero)</li>
     * </ul>
     * 
     * <p>This provides a data-driven approach to vulnerability remediation prioritization,
     * ensuring that the most critical vulnerabilities are addressed first.</p>
     * 
     * @param application the application context
     * @return the response time SLA in hours
     */
    public int calculateResponseTimeSLA(Application application) {
        SeverityScore contextual = calculateContextualScore(application);
        
        int baseHours;
        if (contextual.isCritical()) {
            baseHours = SLA_CRITICAL_HOURS;
        } else if (contextual.isHigh()) {
            baseHours = SLA_HIGH_HOURS;
        } else if (contextual.isMedium()) {
            baseHours = SLA_MEDIUM_HOURS;
        } else {
            baseHours = SLA_LOW_HOURS;
        }
        
        // Critical infrastructure halves the response time
        if (application.isCriticalInfrastructure()) {
            baseHours = (int) (baseHours * CRITICAL_INFRA_SLA_REDUCTION);
        }
        
        return Math.max(SLA_MINIMUM_HOURS, baseHours);
    }
    
    /**
     * Pulls and clears all accumulated domain events.
     * This method should be called after persisting the aggregate to publish events.
     *
     * @return the list of domain events
     */
    public List<DomainEvent> pullDomainEvents() {
        List<DomainEvent> events = new ArrayList<>(this.domainEvents);
        this.domainEvents.clear();
        return events;
    }
    
    public VulnerabilityId getId() {
        return id;
    }
    
    public CveId getCveId() {
        return cveId;
    }
    
    public ApplicationId getApplicationId() {
        return applicationId;
    }
    
    public SeverityScore getBaseScore() {
        return baseScore;
    }
    
    public SeverityScore getContextualScore() {
        return contextualScore;
    }
    
    public CvssVector getCvssVector() {
        return cvssVector;
    }
    
    public VulnerabilityStatus getStatus() {
        return status;
    }
    
    public VulnerabilityType getType() {
        return type;
    }
    
    public String getDescription() {
        return description;
    }
    
    public String getAiJustification() {
        return aiJustification;
    }
    
    public Instant getDetectedAt() {
        return detectedAt;
    }
}
