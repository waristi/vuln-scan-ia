package com.mercadolibre.vulnscania.application.usecase;

import com.mercadolibre.vulnscania.application.port.input.EvaluateVulnerabilityInputPort;
import com.mercadolibre.vulnscania.domain.command.EvaluateVulnerabilityCommand;
import com.mercadolibre.vulnscania.domain.event.DomainEvent;
import com.mercadolibre.vulnscania.domain.exception.ApplicationNotFoundException;
import com.mercadolibre.vulnscania.domain.exception.VulnerabilityNotFoundException;
import com.mercadolibre.vulnscania.domain.model.ai.AIProvider;
import com.mercadolibre.vulnscania.domain.model.application.Application;
import com.mercadolibre.vulnscania.domain.model.assessment.VulnerabilityAssessment;
import com.mercadolibre.vulnscania.domain.model.vulnerability.SeverityScore;
import com.mercadolibre.vulnscania.domain.model.vulnerability.Vulnerability;
import com.mercadolibre.vulnscania.domain.port.output.*;
import com.mercadolibre.vulnscania.domain.service.AIAssessmentValidationService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.function.Function;

/**
 * Use Case: Evaluate Vulnerability
 * 
 * <p>Orchestrates the complete vulnerability evaluation process following the
 * Single Responsibility Principle by delegating specific tasks to private methods.</p>
 * 
 * <p><strong>Main Flow</strong>:</p>
 * <ol>
 *   <li>Fetch vulnerability context (CVE + Application data)</li>
 *   <li>Calculate deterministic baseline score</li>
 *   <li>Optionally perform AI analysis with validation</li>
 *   <li>Create and persist assessment</li>
 *   <li>Publish domain events</li>
 * </ol>
 * 
 * <p>This is the APPLICATION LAYER - orchestrates domain + infrastructure.</p>
 * 
 * <p><strong>Architecture Notes</strong>:</p>
 * <ul>
 *   <li>Framework-independent (transaction management at infrastructure layer)</li>
 *   <li>Implements Input Port for Dependency Inversion (SOLID)</li>
 *   <li>Uses AI provider selection through functional interface to avoid direct infrastructure coupling</li>
 * </ul>
 * 
 * @see EvaluateVulnerabilityInputPort
 * @see AIAssessmentValidationService
 */
public class EvaluateVulnerabilityUseCase implements EvaluateVulnerabilityInputPort {
    
    private static final Logger log = LoggerFactory.getLogger(EvaluateVulnerabilityUseCase.class);
    private static final double DEFAULT_CONFIDENCE_LEVEL = 1.0;
    private static final String DETERMINISTIC_JUSTIFICATION = 
        "Deterministic scoring based on CVSS and application context";
    
    private final VulnerabilityCatalogPort catalogPort;
    private final ApplicationRepository applicationRepository;
    private final VulnerabilityRepository vulnerabilityRepository;
    private final AssessmentRepository assessmentRepository;
    private final Function<String, AIAnalysisPort> aiProviderResolver;
    private final AIAssessmentValidationService validationService;
    private final DomainEventPublisher eventPublisher;
    
    /**
     * Constructor for production use with AI provider selector.
     * 
     * @param catalogPort port for CVE data retrieval
     * @param applicationRepository repository for application entities
     * @param vulnerabilityRepository repository for vulnerability entities
     * @param assessmentRepository repository for assessment entities
     * @param aiProviderResolver function to resolve AI provider by name (from infrastructure layer)
     * @param validationService domain service for AI validation
     * @param eventPublisher publisher for domain events
     */
    public EvaluateVulnerabilityUseCase(
            VulnerabilityCatalogPort catalogPort,
            ApplicationRepository applicationRepository,
            VulnerabilityRepository vulnerabilityRepository,
            AssessmentRepository assessmentRepository,
            Function<String, AIAnalysisPort> aiProviderResolver,
            AIAssessmentValidationService validationService,
            DomainEventPublisher eventPublisher) {
        
        this.catalogPort = catalogPort;
        this.applicationRepository = applicationRepository;
        this.vulnerabilityRepository = vulnerabilityRepository;
        this.assessmentRepository = assessmentRepository;
        this.aiProviderResolver = aiProviderResolver;
        this.validationService = validationService;
        this.eventPublisher = eventPublisher;
    }
    
    /**
     * Executes the vulnerability evaluation use case.
     * 
     * <p>This method orchestrates the high-level flow, delegating specific
     * responsibilities to private methods (Single Responsibility Principle).</p>
     * 
     * <p><strong>Note</strong>: Transactional behavior is managed at the infrastructure 
     * layer (controller) to keep this use case framework-independent.</p>
     * 
     * @param command the evaluation command with CVE and application context
     * @return the assessment result with score, justification, and recommendations
     * @throws VulnerabilityNotFoundException if CVE not found in catalog
     * @throws ApplicationNotFoundException if application not found
     */
    @Override
    public AssessmentResult execute(EvaluateVulnerabilityCommand command) {
        log.info("Evaluating vulnerability {} for application {}", 
            command.cveId().value(), command.applicationId().value());
        
        // Step 1: Fetch vulnerability context (CVE + Application data)
        VulnerabilityContext context = fetchVulnerabilityContext(command);
        
        // Step 2: Calculate deterministic baseline score
        SeverityScore baselineScore = calculateBaselineScore(context);
        
        // Step 3: Perform AI analysis if enabled
        ScoringResult scoringResult = performAIAnalysisIfEnabled(
            command, context, baselineScore
        );
        
        // Step 4: Create and persist assessment
        VulnerabilityAssessment assessment = createAndPersistAssessment(
            context, scoringResult
        );
        
        // Step 5: Publish domain events
        publishDomainEvents(context.vulnerability());
        
        log.info("Vulnerability evaluation completed: {} - Score: {}", 
            command.cveId().value(), scoringResult.finalScore().value());
        
        return buildAssessmentResult(assessment, context, scoringResult);
    }
    
    /**
     * Fetches vulnerability context including CVE data, application, and vulnerability entity.
     * 
     * <p>Handles steps 1-3 of the original execute method.</p>
     * 
     * @param command the evaluation command
     * @return context object with all required data
     * @throws VulnerabilityNotFoundException if CVE not found
     * @throws ApplicationNotFoundException if application not found
     */
    private VulnerabilityContext fetchVulnerabilityContext(EvaluateVulnerabilityCommand command) {
        // Fetch CVE data from NVD
        VulnerabilityCatalogPort.VulnerabilityCatalogData cveData = catalogPort
            .findByCveId(command.cveId())
            .orElseThrow(() -> new VulnerabilityNotFoundException(command.cveId().value()));
        
        // Get application context
        Application application = applicationRepository
            .findById(command.applicationId())
            .orElseThrow(() -> new ApplicationNotFoundException(command.applicationId().value()));
        
        // Get or create vulnerability
        Vulnerability vulnerability = vulnerabilityRepository
            .findByCveIdAndApplicationId(command.cveId(), command.applicationId())
            .orElseGet(() -> Vulnerability.create(
                command.cveId(),
                command.applicationId(),
                cveData.baseScore()
            ));
        
        return new VulnerabilityContext(cveData, application, vulnerability);
    }
    
    /**
     * Calculates the deterministic baseline score using the Rich Domain Model.
     * 
     * <p>The vulnerability entity knows how to calculate its own contextual score
     * based on application context (Tell, Don't Ask principle).</p>
     * 
     * @param context the vulnerability context
     * @return baseline severity score
     */
    private SeverityScore calculateBaselineScore(VulnerabilityContext context) {
        return context.vulnerability().calculateContextualScore(context.application());
    }
    
    /**
     * Performs AI analysis if enabled in the command.
     * 
     * <p>Handles steps 5-6 of the original execute method, including:</p>
     * <ul>
     *   <li>AI provider selection</li>
     *   <li>AI analysis execution</li>
     *   <li>Validation of AI results</li>
     *   <li>Score blending with baseline</li>
     *   <li>Fallback to baseline on errors</li>
     * </ul>
     * 
     * @param command the evaluation command
     * @param context the vulnerability context
     * @param baselineScore the deterministic baseline score
     * @return scoring result with final score and metadata
     */
    private ScoringResult performAIAnalysisIfEnabled(
            EvaluateVulnerabilityCommand command,
            VulnerabilityContext context,
            SeverityScore baselineScore) {
        
        if (!command.useAIAnalysis()) {
            return ScoringResult.withoutAI(baselineScore);
        }
        
        try {
            // Resolve AI provider (infrastructure concern handled via function)
            AIAnalysisPort aiProvider = aiProviderResolver.apply(command.aiProvider());
            
            log.debug("Using AI provider for {}: {}", 
                command.cveId().value(), 
                command.aiProvider() != null ? command.aiProvider() : AIProvider.DEFAULT);
            
            // Execute AI analysis
            AIAnalysisPort.AIAnalysisResult aiResult = aiProvider.analyze(
                context.vulnerability(), 
                context.application()
            );
            
            // Validate and blend AI results
            return validateAndBlendAIResults(aiResult, baselineScore, command.cveId().value());
            
        } catch (Exception e) {
            log.error("AI analysis failed for {}: {}", command.cveId().value(), e.getMessage());
            return ScoringResult.withoutAI(baselineScore);
        }
    }
    
    /**
     * Validates AI analysis results and blends with baseline score.
     * 
     * <p>Applies business rules from {@link AIAssessmentValidationService} to ensure
     * AI doesn't produce unreasonable scores ("hallucinations").</p>
     * 
     * @param aiResult the AI analysis result
     * @param baselineScore the deterministic baseline score
     * @param cveId CVE identifier for logging
     * @return scoring result with validated and blended score
     */
    private ScoringResult validateAndBlendAIResults(
            AIAnalysisPort.AIAnalysisResult aiResult,
            SeverityScore baselineScore,
            String cveId) {
        
        // Check if AI analysis should be rejected
        if (validationService.shouldRejectAIAnalysis(
                aiResult.suggestedScore(),
                baselineScore,
                aiResult.confidenceLevel(),
                aiResult.justification())) {
            
            log.warn("AI analysis rejected for {} - using baseline score", cveId);
            return ScoringResult.withoutAI(baselineScore);
        }
        
        // Validate and constrain AI score
        SeverityScore validatedScore = validationService.validateAndConstrainScore(
            aiResult.suggestedScore(), 
            baselineScore
        );
        
        // Blend AI score with baseline using confidence weighting
        SeverityScore finalScore = validationService.blendScores(
            validatedScore, 
            baselineScore, 
            aiResult.confidenceLevel()
        );
        
        return new ScoringResult(
            finalScore,
            aiResult.justification(),
            aiResult.provider(),
            aiResult.confidenceLevel()
        );
    }
    
    /**
     * Creates, completes, and persists the vulnerability assessment.
     * 
     * <p>Handles steps 7-11 of the original execute method, including:</p>
     * <ul>
     *   <li>Updating vulnerability with final score</li>
     *   <li>Saving vulnerability</li>
     *   <li>Creating assessment</li>
     *   <li>Checking if manual review is required</li>
     *   <li>Persisting assessment</li>
     * </ul>
     * 
     * @param context the vulnerability context
     * @param scoringResult the final scoring result
     * @return the completed and persisted assessment
     */
    private VulnerabilityAssessment createAndPersistAssessment(
            VulnerabilityContext context,
            ScoringResult scoringResult) {
        
        // Update vulnerability with final score and metadata
        context.vulnerability().adjustContextualScore(
            scoringResult.finalScore(), 
            scoringResult.justification()
        );
        context.vulnerability().updateMetadata(
            context.cveData().cvssVector(), 
            null, 
            context.cveData().description()
        );
        
        // Save vulnerability
        vulnerabilityRepository.save(context.vulnerability());
        
        // Create and complete assessment
        VulnerabilityAssessment assessment = VulnerabilityAssessment.startNew(
            context.vulnerability(), 
            context.application()
        );
        assessment.complete(
            scoringResult.finalScore(),
            scoringResult.justification(),
            scoringResult.aiProvider(),
            scoringResult.confidenceLevel()
        );
        
        // Check if manual review is required
        boolean requiresReview = validationService.requiresHumanReview(
            scoringResult.finalScore(),
            scoringResult.finalScore(),
            context.vulnerability().calculateContextualScore(context.application()),
            scoringResult.confidenceLevel()
        );
        
        if (requiresReview) {
            assessment.requiresReview("Low confidence or critical score - manual review recommended");
        }
        
        // Persist assessment
        assessmentRepository.save(assessment);
        
        return assessment;
    }
    
    /**
     * Publishes accumulated domain events from the vulnerability aggregate.
     * 
     * <p>Domain events are pulled from the aggregate and published to interested
     * listeners (e.g., notification services, audit logs).</p>
     * 
     * @param vulnerability the vulnerability aggregate with events
     */
    private void publishDomainEvents(Vulnerability vulnerability) {
        List<DomainEvent> events = vulnerability.pullDomainEvents();
        eventPublisher.publishAll(events);
    }
    
    /**
     * Builds the assessment result DTO for the use case response.
     * 
     * @param assessment the completed assessment
     * @param context the vulnerability context
     * @param scoringResult the final scoring result
     * @return assessment result DTO
     */
    private AssessmentResult buildAssessmentResult(
            VulnerabilityAssessment assessment,
            VulnerabilityContext context,
            ScoringResult scoringResult) {
        
        boolean requiresReview = validationService.requiresHumanReview(
            scoringResult.finalScore(),
            scoringResult.finalScore(),
            context.vulnerability().calculateContextualScore(context.application()),
            scoringResult.confidenceLevel()
        );
        
        return new AssessmentResult(
            assessment.getId().value(),
            context.vulnerability().getId().value(),
            context.vulnerability().getCveId().value(),
            context.vulnerability().getApplicationId().value(),
            scoringResult.finalScore().value(),
            context.vulnerability().getSeverityLevel().name(),
            scoringResult.justification(),
            scoringResult.confidenceLevel(),
            requiresReview,
            context.vulnerability().requiresImmediateAction(context.application()),
            context.vulnerability().calculateResponseTimeSLA(context.application())
        );
    }
    
    // ========== Internal Value Objects ==========
    
    /**
     * Internal context object holding all vulnerability-related data.
     * 
     * <p>Reduces parameter passing between private methods.</p>
     * 
     * @param cveData CVE catalog data from NVD
     * @param application the application context
     * @param vulnerability the vulnerability aggregate
     */
    private record VulnerabilityContext(
        VulnerabilityCatalogPort.VulnerabilityCatalogData cveData,
        Application application,
        Vulnerability vulnerability
    ) {}
    
    /**
     * Internal scoring result object.
     * 
     * <p>Encapsulates the result of scoring (baseline or AI-enhanced).</p>
     * 
     * @param finalScore the final calculated score
     * @param justification the justification for the score
     * @param aiProvider the AI provider used (null if baseline only)
     * @param confidenceLevel confidence level (0.0 - 1.0)
     */
    private record ScoringResult(
        SeverityScore finalScore,
        String justification,
        String aiProvider,
        double confidenceLevel
    ) {
        /**
         * Creates a scoring result without AI analysis (baseline only).
         * 
         * @param baselineScore the baseline score
         * @return scoring result with high confidence (deterministic)
         */
        static ScoringResult withoutAI(SeverityScore baselineScore) {
            return new ScoringResult(
                baselineScore,
                DETERMINISTIC_JUSTIFICATION,
                null,
                DEFAULT_CONFIDENCE_LEVEL
            );
        }
    }
    
    // ========== Public Result DTO ==========
    
    /**
     * Result DTO for the use case.
     * 
     * <p>Contains all information about the completed vulnerability assessment.</p>
     * 
     * @param assessmentId unique assessment identifier
     * @param vulnerabilityId unique vulnerability identifier
     * @param cveId CVE identifier
     * @param applicationId application identifier
     * @param finalScore final severity score (0.0 - 10.0)
     * @param severityLevel categorical severity (CRITICAL, HIGH, MEDIUM, LOW)
     * @param justification detailed justification for the score
     * @param confidenceLevel confidence in the assessment (0.0 - 1.0)
     * @param requiresManualReview whether human review is recommended
     * @param requiresImmediateAction whether immediate action is required
     * @param responseSlaHours response time SLA in hours
     */
    public record AssessmentResult(
        String assessmentId,
        String vulnerabilityId,
        String cveId,
        String applicationId,
        double finalScore,
        String severityLevel,
        String justification,
        double confidenceLevel,
        boolean requiresManualReview,
        boolean requiresImmediateAction,
        int responseSlaHours
    ) {}
}
