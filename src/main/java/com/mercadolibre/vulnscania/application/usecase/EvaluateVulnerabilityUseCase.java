package com.mercadolibre.vulnscania.application.usecase;

import com.mercadolibre.vulnscania.domain.command.EvaluateVulnerabilityCommand;
import com.mercadolibre.vulnscania.domain.event.DomainEvent;
import com.mercadolibre.vulnscania.domain.exception.ApplicationNotFoundException;
import com.mercadolibre.vulnscania.domain.exception.VulnerabilityNotFoundException;
import com.mercadolibre.vulnscania.domain.model.application.Application;
import com.mercadolibre.vulnscania.domain.model.assessment.VulnerabilityAssessment;
import com.mercadolibre.vulnscania.domain.model.vulnerability.SeverityScore;
import com.mercadolibre.vulnscania.domain.model.vulnerability.Vulnerability;
import com.mercadolibre.vulnscania.domain.port.output.*;
import com.mercadolibre.vulnscania.domain.service.AIAssessmentValidationService;
import com.mercadolibre.vulnscania.domain.service.VulnerabilityScoringService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

/**
 * Use Case: Evaluate Vulnerability
 * 
 * Orchestrates the complete vulnerability evaluation process:
 * 1. Fetch CVE data from NVD
 * 2. Get application context
 * 3. Calculate contextual score (deterministic)
 * 4. Optionally get AI analysis
 * 5. Validate and blend AI score with baseline
 * 6. Create or update vulnerability
 * 7. Create assessment
 * 8. Publish domain events
 * 
 * This is the APPLICATION LAYER - orchestrates domain + infrastructure.
 */
@Service
public class EvaluateVulnerabilityUseCase {
    
    private static final Logger log = LoggerFactory.getLogger(EvaluateVulnerabilityUseCase.class);
    
    private final VulnerabilityCatalogPort catalogPort;
    private final ApplicationRepository applicationRepository;
    private final VulnerabilityRepository vulnerabilityRepository;
    private final AssessmentRepository assessmentRepository;
    private final AIAnalysisPort aiAnalysisPort;
    private final VulnerabilityScoringService scoringService;
    private final AIAssessmentValidationService validationService;
    private final DomainEventPublisher eventPublisher;
    
    public EvaluateVulnerabilityUseCase(
            VulnerabilityCatalogPort catalogPort,
            ApplicationRepository applicationRepository,
            VulnerabilityRepository vulnerabilityRepository,
            AssessmentRepository assessmentRepository,
            AIAnalysisPort aiAnalysisPort,
            VulnerabilityScoringService scoringService,
            AIAssessmentValidationService validationService,
            DomainEventPublisher eventPublisher) {
        
        this.catalogPort = catalogPort;
        this.applicationRepository = applicationRepository;
        this.vulnerabilityRepository = vulnerabilityRepository;
        this.assessmentRepository = assessmentRepository;
        this.aiAnalysisPort = aiAnalysisPort;
        this.scoringService = scoringService;
        this.validationService = validationService;
        this.eventPublisher = eventPublisher;
    }
    
    @Transactional
    public AssessmentResult execute(EvaluateVulnerabilityCommand command) {
        log.info("Evaluating vulnerability {} for application {}", 
            command.cveId().value(), command.applicationId().value());
        
        // Step 1: Fetch CVE data from NVD
        VulnerabilityCatalogPort.VulnerabilityCatalogData cveData = catalogPort
            .findByCveId(command.cveId())
            .orElseThrow(() -> new VulnerabilityNotFoundException(command.cveId().value()));
        
        // Step 2: Get application context
        Application application = applicationRepository
            .findById(command.applicationId())
            .orElseThrow(() -> new ApplicationNotFoundException(command.applicationId().value()));
        
        // Step 3: Create or get existing vulnerability
        Vulnerability vulnerability = getOrCreateVulnerability(command, cveData, application);
        
        // Step 4: Calculate deterministic contextual score
        SeverityScore baselineScore = scoringService.calculateContextualScore(vulnerability, application);
        
        // Step 5: Get AI analysis (if enabled)
        SeverityScore finalScore = baselineScore;
        String justification = "Deterministic scoring based on CVSS and application context";
        String aiAnalysis = null;
        double confidenceLevel = 1.0;
        
        if (command.useAIAnalysis()) {
            try {
                AIAnalysisPort.AIAnalysisResult aiResult = aiAnalysisPort.analyze(vulnerability, application);
                
                // Step 6: Validate AI result
                if (validationService.shouldRejectAIAnalysis(
                        aiResult.suggestedScore(),
                        baselineScore,
                        aiResult.confidenceLevel(),
                        aiResult.justification())) {
                    
                    log.warn("AI analysis rejected for {} - using baseline score", command.cveId().value());
                    finalScore = baselineScore;
                } else {
                    // Blend AI score with baseline
                    SeverityScore validatedScore = validationService.validateAndConstrainScore(
                        aiResult.suggestedScore(), baselineScore
                    );
                    
                    finalScore = validationService.blendScores(
                        validatedScore, baselineScore, aiResult.confidenceLevel()
                    );
                    
                    justification = aiResult.justification();
                    aiAnalysis = aiResult.provider();
                    confidenceLevel = aiResult.confidenceLevel();
                }
            } catch (Exception e) {
                log.error("AI analysis failed for {}: {}", command.cveId().value(), e.getMessage());
                // Continue with baseline score
            }
        }
        
        // Step 7: Update vulnerability with final score
        vulnerability.adjustContextualScore(finalScore, justification);
        vulnerability.updateMetadata(cveData.cvssVector(), null, cveData.description());
        
        // Step 8: Save vulnerability
        vulnerabilityRepository.save(vulnerability);
        
        // Step 9: Create and complete assessment
        VulnerabilityAssessment assessment = VulnerabilityAssessment.startNew(vulnerability, application);
        assessment.complete(finalScore, justification, aiAnalysis, confidenceLevel);
        assessmentRepository.save(assessment);
        
        // Step 10: Publish domain events
        List<DomainEvent> events = vulnerability.pullDomainEvents();
        eventPublisher.publishAll(events);
        
        // Step 11: Check if requires manual review
        boolean requiresReview = validationService.requiresHumanReview(
            finalScore, finalScore, baselineScore, confidenceLevel
        );
        
        if (requiresReview) {
            assessment.requiresReview("Low confidence or critical score - manual review recommended");
            assessmentRepository.save(assessment);
        }
        
        log.info("Vulnerability evaluation completed: {} - Score: {}", 
            command.cveId().value(), finalScore.value());
        
        return new AssessmentResult(
            assessment.getId().value(),
            vulnerability.getId().value(),
            command.cveId().value(),
            command.applicationId().value(),
            finalScore.value(),
            vulnerability.getSeverityLevel().name(),
            justification,
            confidenceLevel,
            requiresReview,
            vulnerability.requiresImmediateAction(),
            scoringService.calculateResponseTimeSLA(vulnerability, application)
        );
    }
    
    /**
     * Gets existing vulnerability or creates new one.
     */
    private Vulnerability getOrCreateVulnerability(
            EvaluateVulnerabilityCommand command,
            VulnerabilityCatalogPort.VulnerabilityCatalogData cveData,
            Application application) {
        
        return vulnerabilityRepository
            .findByCveIdAndApplicationId(command.cveId(), command.applicationId())
            .orElseGet(() -> Vulnerability.create(
                command.cveId(),
                command.applicationId(),
                cveData.baseScore()
            ));
    }
    
    /**
     * Result DTO for the use case.
     */
    public record AssessmentResult(
        String assessmentId,
        String vulnerabilityId,
        String cveId,
        String applicationId,
        double finalScore,
        String severityLevel,
        String justification,
        double confidenceLevel,
        boolean requiresManualReview,
        boolean requiresImmediateAction,
        int responseSlaHours
    ) {}
}

