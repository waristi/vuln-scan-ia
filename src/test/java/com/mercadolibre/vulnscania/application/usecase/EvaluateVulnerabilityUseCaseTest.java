package com.mercadolibre.vulnscania.application.usecase;

import com.mercadolibre.vulnscania.domain.command.EvaluateVulnerabilityCommand;
import com.mercadolibre.vulnscania.domain.model.application.Application;
import com.mercadolibre.vulnscania.domain.model.application.ApplicationId;
import com.mercadolibre.vulnscania.domain.model.application.DataSensitivity;
import com.mercadolibre.vulnscania.domain.model.assessment.VulnerabilityAssessment;
import com.mercadolibre.vulnscania.domain.model.vulnerability.CveId;
import com.mercadolibre.vulnscania.domain.model.vulnerability.SeverityScore;
import com.mercadolibre.vulnscania.domain.model.vulnerability.Vulnerability;
import com.mercadolibre.vulnscania.domain.port.output.*;
import com.mercadolibre.vulnscania.domain.service.AIAssessmentValidationService;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.List;
import java.util.Optional;

import static org.assertj.core.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class EvaluateVulnerabilityUseCaseTest {
    
    @Mock
    private VulnerabilityCatalogPort catalogPort;
    
    @Mock
    private ApplicationRepository applicationRepository;
    
    @Mock
    private VulnerabilityRepository vulnerabilityRepository;
    
    @Mock
    private AssessmentRepository assessmentRepository;
    
    @Mock
    private AIAnalysisPort aiAnalysisPort;
    
    @Mock
    private AIAssessmentValidationService validationService;
    
    @Mock
    private DomainEventPublisher eventPublisher;
    
    private EvaluateVulnerabilityUseCase useCase;
    
    @BeforeEach
    void setUp() {
        useCase = new EvaluateVulnerabilityUseCase(
            catalogPort,
            applicationRepository,
            vulnerabilityRepository,
            assessmentRepository,
            aiAnalysisPort,
            validationService,
            eventPublisher
        );
    }
    
    @Test
    void shouldEvaluateVulnerabilitySuccessfully() {
        // Given
        CveId cveId = new CveId("CVE-2024-1234");
        ApplicationId appId = ApplicationId.of("app-123");
        EvaluateVulnerabilityCommand command = new EvaluateVulnerabilityCommand(cveId, appId, false);
        
        Application application = Application.create(
            "Test App",
            List.of("Java"),
            List.of(),
            true,
            DataSensitivity.SENSITIVE,
            List.of("PRODUCTION")
        );
        
        VulnerabilityCatalogPort.VulnerabilityCatalogData cveData = 
            new VulnerabilityCatalogPort.VulnerabilityCatalogData(
                cveId,
                "Test vulnerability",
                new SeverityScore(7.5),
                new com.mercadolibre.vulnscania.domain.model.vulnerability.CvssVector("CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"),
                "2024-01-15",
                "2024-02-01"
            );
        
        when(catalogPort.findByCveId(cveId)).thenReturn(Optional.of(cveData));
        when(applicationRepository.findById(appId)).thenReturn(Optional.of(application));
        when(vulnerabilityRepository.findByCveIdAndApplicationId(cveId, appId))
            .thenReturn(Optional.empty());
        when(vulnerabilityRepository.save(any(Vulnerability.class)))
            .thenAnswer(invocation -> invocation.getArgument(0));
        when(assessmentRepository.save(any(VulnerabilityAssessment.class)))
            .thenAnswer(invocation -> invocation.getArgument(0));
        when(validationService.requiresHumanReview(any(), any(), any(), anyDouble()))
            .thenReturn(false);
        
        // When
        EvaluateVulnerabilityUseCase.AssessmentResult result = useCase.execute(command);
        
        // Then
        assertThat(result).isNotNull();
        assertThat(result.cveId()).isEqualTo("CVE-2024-1234");
        assertThat(result.applicationId()).isEqualTo("app-123");
        
        verify(catalogPort).findByCveId(cveId);
        verify(applicationRepository).findById(appId);
        verify(vulnerabilityRepository).save(any(Vulnerability.class));
        verify(assessmentRepository).save(any(VulnerabilityAssessment.class));
        verify(eventPublisher).publishAll(any());
    }
    
    @Test
    void shouldUseExistingVulnerabilityIfFound() {
        // Given
        CveId cveId = new CveId("CVE-2024-1234");
        ApplicationId appId = ApplicationId.of("app-123");
        EvaluateVulnerabilityCommand command = new EvaluateVulnerabilityCommand(cveId, appId, false);
        
        Application application = Application.create(
            "Test App",
            List.of("Java"),
            List.of(),
            false,
              DataSensitivity.INTERNAL,
            List.of("DEVELOPMENT")
        );
        
        Vulnerability existingVuln = Vulnerability.create(cveId, appId, new SeverityScore(7.5));
        
        VulnerabilityCatalogPort.VulnerabilityCatalogData cveData = 
            new VulnerabilityCatalogPort.VulnerabilityCatalogData(
                cveId,
                "Test vulnerability",
                new SeverityScore(7.5),
                new com.mercadolibre.vulnscania.domain.model.vulnerability.CvssVector("CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"),
                "2024-01-15",
                "2024-02-01"
            );
        
        when(catalogPort.findByCveId(cveId)).thenReturn(Optional.of(cveData));
        when(applicationRepository.findById(appId)).thenReturn(Optional.of(application));
        when(vulnerabilityRepository.findByCveIdAndApplicationId(cveId, appId))
            .thenReturn(Optional.of(existingVuln));
        when(vulnerabilityRepository.save(any(Vulnerability.class)))
            .thenAnswer(invocation -> invocation.getArgument(0));
        when(assessmentRepository.save(any(VulnerabilityAssessment.class)))
            .thenAnswer(invocation -> invocation.getArgument(0));
        when(validationService.requiresHumanReview(any(), any(), any(), anyDouble()))
            .thenReturn(false);
        
        // When
        useCase.execute(command);
        
        // Then
        verify(vulnerabilityRepository).findByCveIdAndApplicationId(cveId, appId);
    }
    
    @Test
    void shouldUseAIAnalysisWhenEnabled() {
        // Given
        CveId cveId = new CveId("CVE-2024-1234");
        ApplicationId appId = ApplicationId.of("app-123");
        EvaluateVulnerabilityCommand command = new EvaluateVulnerabilityCommand(cveId, appId, true);
        
        Application application = Application.create(
            "Test App",
            List.of("Java"),
            List.of(),
            true,
            DataSensitivity.SENSITIVE,
            List.of("PRODUCTION")
        );
        
        VulnerabilityCatalogPort.VulnerabilityCatalogData cveData = 
            new VulnerabilityCatalogPort.VulnerabilityCatalogData(
                cveId,
                "Test vulnerability",
                new SeverityScore(7.5),
                new com.mercadolibre.vulnscania.domain.model.vulnerability.CvssVector("CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"),
                "2024-01-15",
                "2024-02-01"
            );
        
        AIAnalysisPort.AIAnalysisResult aiResult = new AIAnalysisPort.AIAnalysisResult(
            new SeverityScore(8.0),
            "AI analysis suggests higher risk",
            0.85,
            "OpenAI"
        );
        
        when(catalogPort.findByCveId(cveId)).thenReturn(Optional.of(cveData));
        when(applicationRepository.findById(appId)).thenReturn(Optional.of(application));
        when(vulnerabilityRepository.findByCveIdAndApplicationId(cveId, appId))
            .thenReturn(Optional.empty());
        when(aiAnalysisPort.analyze(any(Vulnerability.class), any(Application.class)))
            .thenReturn(aiResult);
        when(validationService.shouldRejectAIAnalysis(any(), any(), anyDouble(), anyString()))
            .thenReturn(false);
        when(validationService.validateAndConstrainScore(any(), any()))
            .thenReturn(new SeverityScore(8.0));
        when(validationService.blendScores(any(), any(), anyDouble()))
            .thenReturn(new SeverityScore(7.8));
        when(vulnerabilityRepository.save(any(Vulnerability.class)))
            .thenAnswer(invocation -> invocation.getArgument(0));
        when(assessmentRepository.save(any(VulnerabilityAssessment.class)))
            .thenAnswer(invocation -> invocation.getArgument(0));
        when(validationService.requiresHumanReview(any(), any(), any(), anyDouble()))
            .thenReturn(false);
        
        // When
        useCase.execute(command);
        
        // Then
        verify(aiAnalysisPort).analyze(any(Vulnerability.class), any(Application.class));
        verify(validationService).shouldRejectAIAnalysis(any(), any(), anyDouble(), anyString());
    }
    
    @Test
    void shouldFallbackToBaselineWhenAIAnalysisRejected() {
        // Given
        CveId cveId = new CveId("CVE-2024-1234");
        ApplicationId appId = ApplicationId.of("app-123");
        EvaluateVulnerabilityCommand command = new EvaluateVulnerabilityCommand(cveId, appId, true);
        
        Application application = Application.create(
            "Test App",
            List.of("Java"),
            List.of(),
            false,
            DataSensitivity.CONFIDENTIAL,
            List.of("STAGING")
        );
        
        VulnerabilityCatalogPort.VulnerabilityCatalogData cveData = 
            new VulnerabilityCatalogPort.VulnerabilityCatalogData(
                cveId,
                "Test vulnerability",
                new SeverityScore(7.5),
                new com.mercadolibre.vulnscania.domain.model.vulnerability.CvssVector("CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"),
                "2024-01-15",
                "2024-02-01"
            );
        
        AIAnalysisPort.AIAnalysisResult aiResult = new AIAnalysisPort.AIAnalysisResult(
            new SeverityScore(10.0),  // Suspiciously high
            "Unrealistic analysis",
            0.1,  // Low confidence
            "OpenAI"
        );
        
        when(catalogPort.findByCveId(cveId)).thenReturn(Optional.of(cveData));
        when(applicationRepository.findById(appId)).thenReturn(Optional.of(application));
        when(vulnerabilityRepository.findByCveIdAndApplicationId(cveId, appId))
            .thenReturn(Optional.empty());
        when(aiAnalysisPort.analyze(any(Vulnerability.class), any(Application.class)))
            .thenReturn(aiResult);
        when(validationService.shouldRejectAIAnalysis(any(), any(), anyDouble(), anyString()))
            .thenReturn(true);  // Reject AI analysis
        when(vulnerabilityRepository.save(any(Vulnerability.class)))
            .thenAnswer(invocation -> invocation.getArgument(0));
        when(assessmentRepository.save(any(VulnerabilityAssessment.class)))
            .thenAnswer(invocation -> invocation.getArgument(0));
        when(validationService.requiresHumanReview(any(), any(), any(), anyDouble()))
            .thenReturn(false);
        
        // When
        EvaluateVulnerabilityUseCase.AssessmentResult result = useCase.execute(command);
        
        // Then
        verify(validationService).shouldRejectAIAnalysis(any(), any(), anyDouble(), anyString());
        verify(validationService, never()).blendScores(any(), any(), anyDouble());
    }
    
    @Test
    void shouldMarkForReviewWhenNeeded() {
        // Given
        CveId cveId = new CveId("CVE-2024-1234");
        ApplicationId appId = ApplicationId.of("app-123");
        EvaluateVulnerabilityCommand command = new EvaluateVulnerabilityCommand(cveId, appId, false);
        
        Application application = Application.create(
            "Test App",
            List.of("Java"),
            List.of(),
            true,
              DataSensitivity.HIGHLY_REGULATED,
            List.of("PRODUCTION")
        );
        
        VulnerabilityCatalogPort.VulnerabilityCatalogData cveData = 
            new VulnerabilityCatalogPort.VulnerabilityCatalogData(
                cveId,
                "Test vulnerability",
                new SeverityScore(9.5),
                new com.mercadolibre.vulnscania.domain.model.vulnerability.CvssVector("CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"),
                "2024-01-15",
                "2024-02-01"
            );
        
        when(catalogPort.findByCveId(cveId)).thenReturn(Optional.of(cveData));
        when(applicationRepository.findById(appId)).thenReturn(Optional.of(application));
        when(vulnerabilityRepository.findByCveIdAndApplicationId(cveId, appId))
            .thenReturn(Optional.empty());
        when(vulnerabilityRepository.save(any(Vulnerability.class)))
            .thenAnswer(invocation -> invocation.getArgument(0));
        when(assessmentRepository.save(any(VulnerabilityAssessment.class)))
            .thenAnswer(invocation -> invocation.getArgument(0));
        when(validationService.requiresHumanReview(any(), any(), any(), anyDouble()))
            .thenReturn(true);  // Requires review
        
        // When
        EvaluateVulnerabilityUseCase.AssessmentResult result = useCase.execute(command);
        
        // Then
        assertThat(result.requiresManualReview()).isTrue();
        verify(assessmentRepository, times(2)).save(any(VulnerabilityAssessment.class));
    }
}

