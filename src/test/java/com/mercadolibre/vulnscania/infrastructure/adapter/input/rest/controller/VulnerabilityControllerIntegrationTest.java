package com.mercadolibre.vulnscania.infrastructure.adapter.input.rest.controller;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.mercadolibre.vulnscania.domain.model.application.Application;
import com.mercadolibre.vulnscania.domain.model.application.DataSensitivity;
import com.mercadolibre.vulnscania.domain.model.vulnerability.CveId;
import com.mercadolibre.vulnscania.domain.model.vulnerability.SeverityScore;
import com.mercadolibre.vulnscania.domain.model.vulnerability.Vulnerability;
import com.mercadolibre.vulnscania.domain.model.vulnerability.VulnerabilityType;
import com.mercadolibre.vulnscania.domain.port.output.ApplicationRepository;
import com.mercadolibre.vulnscania.domain.port.output.VulnerabilityCatalogPort;
import com.mercadolibre.vulnscania.domain.port.output.VulnerabilityRepository;
import com.mercadolibre.vulnscania.infrastructure.adapter.input.rest.dto.EvaluateVulnerabilityRequest;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.http.MediaType;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;

import java.util.List;
import java.util.Optional;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@SpringBootTest(properties = {
    "spring.data.mongodb.uri=mongodb://localhost:27017/vuln-scan-test",
    "ai.fallback.enabled=true"
})
@AutoConfigureMockMvc
@ActiveProfiles("test")
class VulnerabilityControllerIntegrationTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @Autowired
    private ObjectMapper objectMapper;
    
    @MockBean
    private VulnerabilityCatalogPort catalogPort;
    
    @Autowired
    private ApplicationRepository applicationRepository;
    
    @Autowired
    private VulnerabilityRepository vulnerabilityRepository;
    
    private Application testApplication;
    
    @BeforeEach
    void setUp() {
        // Clean repositories
        vulnerabilityRepository.findCriticalVulnerabilities().forEach(v -> 
            vulnerabilityRepository.deleteById(v.getId()));
        applicationRepository.findAll().forEach(a -> 
            applicationRepository.deleteById(a.getId()));
        
        // Create test application
        testApplication = Application.create(
            "Test Application",
            List.of("Java", "Spring Boot"),
            List.of(),
            true,
            DataSensitivity.SENSITIVE,
            List.of("PRODUCTION")
        );
        testApplication = applicationRepository.save(testApplication);
    }
    
    @Test
    void shouldEvaluateVulnerabilitySuccessfully() throws Exception {
        // Given
        CveId cveId = new CveId("CVE-2024-1234");
        
        VulnerabilityCatalogPort.VulnerabilityCatalogData cveData = 
            new VulnerabilityCatalogPort.VulnerabilityCatalogData(
                cveId,
                "Test vulnerability - SQL Injection",
                new SeverityScore(7.5),
                new com.mercadolibre.vulnscania.domain.model.vulnerability.CvssVector("CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H"),
                "2024-01-15",
                "2024-02-01"
            );
        
        when(catalogPort.findByCveId(any(CveId.class))).thenReturn(Optional.of(cveData));
        
        EvaluateVulnerabilityRequest request = new EvaluateVulnerabilityRequest(
            "CVE-2024-1234",
            testApplication.getId().value(),
            "gemini",
            null
        );
        
        // When/Then
        mockMvc.perform(post("/api/v1/vulnerabilities/evaluate")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(request)))
            .andExpect(status().isCreated())
            .andExpect(jsonPath("$.cveId").value("CVE-2024-1234"))
            .andExpect(jsonPath("$.applicationId").value(testApplication.getId().value()))
            .andExpect(jsonPath("$.finalScore").exists())
            .andExpect(jsonPath("$.severityLevel").exists())
            .andExpect(jsonPath("$.justification").exists());
    }
    
    @Test
    void shouldReturnBadRequestForInvalidCveFormat() throws Exception {
        // Given
        EvaluateVulnerabilityRequest request = new EvaluateVulnerabilityRequest(
            "INVALID-CVE",
            testApplication.getId().value(),
            "gemini",
            null
        );
        
        // When/Then
        mockMvc.perform(post("/api/v1/vulnerabilities/evaluate")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(request)))
            .andExpect(status().isBadRequest());
    }
    
    @Test
    void shouldGetVulnerabilityStatus() throws Exception {
        // Given
        Vulnerability vulnerability = Vulnerability.create(
            new CveId("CVE-2024-5678"),
            testApplication.getId(),
            new SeverityScore(7.5)
        );
        vulnerability.updateMetadata(
            null,
            VulnerabilityType.SQL_INJECTION,
            "SQL Injection vulnerability"
        );
        vulnerability = vulnerabilityRepository.save(vulnerability);
        
        // When/Then
        mockMvc.perform(get("/api/v1/vulnerabilities/" + vulnerability.getId().value()))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.id").value(vulnerability.getId().value()))
            .andExpect(jsonPath("$.cveId").value("CVE-2024-5678"))
            .andExpect(jsonPath("$.baseScore").value(7.5));
    }
    
    @Test
    void shouldReturn404ForNonExistentVulnerability() throws Exception {
        // When/Then
        mockMvc.perform(get("/api/v1/vulnerabilities/non-existent-id"))
            .andExpect(status().isNotFound());
    }
}

